# Guia de Arquitetura Limpa - Design Patterns & PrincÃ­pios

## Ãndice

1. [API Client - Boundary Layer](#api-client---boundary-layer)
2. [LÃ³gica Pura - Core do NegÃ³cio](#lÃ³gica-pura---core-do-negÃ³cio)
3. [Orchestrator - Dependency Injection](#orchestrator---dependency-injection)

---

## API Client - Boundary Layer (I/O Isolado)

### ğŸ“‹ VisÃ£o Geral

Este arquivo representa a camada de **FRONTEIRA** entre nosso sistema e o mundo externo.
Aqui ficam as chamadas HTTP, leitura de arquivos, banco de dados, etc.

### ğŸ¯ PrincÃ­pios Aplicados

#### 1. Single Responsibility Principle
- Esta classe tem **UMA** responsabilidade: comunicar com a API externa
- NÃ£o faz cÃ¡lculos, nÃ£o orquestra fluxo, apenas I/O

#### 2. Boundary Pattern (Clean Architecture)
- Isola o mundo externo do nosso Core
- Facilita trocar implementaÃ§Ãµes (ex: mudar de REST para GraphQL)
- Permite mockar facilmente em testes

#### 3. Fail Fast & Explicit
- Erros de I/O sÃ£o propagados claramente
- NÃ£o esconde problemas de rede/API

### ğŸ“š Conceito: Hexagonal Architecture (Ports & Adapters)

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   APLICAÃ‡ÃƒO (Core)  â”‚
         â”‚   â€¢ ScoringLogic    â”‚
         â”‚   â€¢ Orchestrator    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ usa (interface/port)
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   ADAPTER/BOUNDARY  â”‚  â† VOCÃŠ ESTÃ AQUI!
         â”‚   â€¢ CustomerApiClientâ”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ fala com
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   MUNDO EXTERNO     â”‚
         â”‚   â€¢ API REST        â”‚
         â”‚   â€¢ Database        â”‚
         â”‚   â€¢ S3              â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’¡ BenefÃ­cios desta SeparaÃ§Ã£o

#### 1. Testabilidade
- Em testes, mockamos ESTA classe
- NÃ£o precisamos de servidor HTTP rodando

#### 2. Flexibilidade
- Mudar de requests para httpx? SÃ³ muda aqui!
- Mudar de REST para GraphQL? SÃ³ muda aqui!
- Adicionar cache? SÃ³ muda aqui!

#### 3. Manutenibilidade
- Todos os problemas de rede estÃ£o concentrados aqui
- FÃ¡cil adicionar retry logic, circuit breaker, etc.

### ğŸ“ Responsabilidades

Cliente para comunicaÃ§Ã£o com API externa de dados de clientes.

**Responsabilidade Ãšnica: APENAS falar com a API.**

#### Esta classe NÃƒO faz:
- âŒ CÃ¡lculos de score (isso Ã© ScoringLogic)
- âŒ OrquestraÃ§Ã£o de fluxo (isso Ã© Orchestrator)
- âŒ ValidaÃ§Ã£o de regras de negÃ³cio (isso Ã© Core)

#### Esta classe FAZ:
- âœ… Chamadas HTTP para API externa
- âœ… SerializaÃ§Ã£o/DeserializaÃ§Ã£o de JSON
- âœ… (Futuro) Retry logic, timeout, error handling

### ğŸ“ Design Pattern: Adapter Pattern

Esta classe Ã© um "Adapter" que adapta a interface da API externa para o formato que nossa aplicaÃ§Ã£o espera.

**Exemplo de mudanÃ§a isolada:**

Se amanhÃ£ a API mudar de:
```
GET /customers/{id}
```

Para:
```
POST /api/v2/customer-data
```

**SÃ³ precisamos mudar ESTA classe!**

O resto do cÃ³digo (Orchestrator, Logic) permanece intacto.

---

## LÃ³gica Pura - Core do NegÃ³cio (SEM I/O)

### ğŸ“‹ VisÃ£o Geral

Este arquivo contÃ©m **APENAS** lÃ³gica de negÃ³cio pura.
Nenhuma dependÃªncia externa. Nenhum I/O. Apenas matemÃ¡tica e regras.

### ğŸ¯ PrincÃ­pios Aplicados

#### 1. Pure Functions (FunÃ§Ãµes Puras)
- Mesma entrada â†’ Mesma saÃ­da (determinÃ­stico)
- Sem efeitos colaterais (nÃ£o muda estado externo)
- Sem I/O (nÃ£o lÃª arquivos, banco, rede)

#### 2. Testabilidade
- NÃ£o precisa de mocks!
- Testes sÃ£o RÃPIDOS (milissegundos)
- Testes sÃ£o CONFIÃVEIS (nÃ£o dependem de rede/disco)

#### 3. Single Responsibility
- Esta classe sÃ³ cuida das REGRAS DE NEGÃ“CIO
- Nada de HTTP, banco de dados, ou modelos ML

### ğŸ“š Conceito: Separation of Concerns

Em Clean Architecture, dividimos o cÃ³digo em camadas:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CORE (LÃ³gica Pura)          â”‚  â† VOCÃŠ ESTÃ AQUI!
â”‚  â€¢ Regras de negÃ³cio                â”‚
â”‚  â€¢ Sem I/O                          â”‚
â”‚  â€¢ TestÃ¡vel sem mocks               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†‘
           â”‚ Usa (sem dependÃªncia de infraestrutura)
           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     BOUNDARY (I/O / Infraestrutura) â”‚
â”‚  â€¢ HTTP, Banco, Arquivos            â”‚
â”‚  â€¢ Modelos ML (carregamento)        â”‚
â”‚  â€¢ TestÃ¡vel COM mocks               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’¡ Regra de Ouro

**O CORE nunca depende do BOUNDARY.**
**O BOUNDARY pode usar o CORE.**

### ğŸ“ CaracterÃ­sticas da LÃ³gica Pura

#### Esta classe nÃ£o tem:
- âŒ DependÃªncias externas (sem imports de libs de I/O)
- âŒ Estado mutÃ¡vel (stateless)
- âŒ Efeitos colaterais (nÃ£o muda nada fora dela)

#### Esta classe tem:
- âœ… Regras de negÃ³cio explÃ­citas
- âœ… FunÃ§Ãµes puras (determinÃ­sticas)
- âœ… Facilidade de teste (sem mocks!)

### ğŸ“ Design Pattern: Strategy Pattern (implÃ­cito)

Ao isolar a lÃ³gica aqui, facilitamos trocar a estratÃ©gia de cÃ¡lculo.

**AmanhÃ£, se a regra de negÃ³cio mudar:**
- NÃ£o preciso mexer em I/O
- NÃ£o preciso mexer em orquestraÃ§Ã£o
- SÃ³ mudo esta classe!

**Exemplos de mudanÃ§as futuras fÃ¡ceis:**
- "Idade agora vale 0.2 pontos" â†’ Muda sÃ³ aqui
- "Renda deve ser dividida por 1500" â†’ Muda sÃ³ aqui
- "HistÃ³rico tem peso exponencial" â†’ Muda sÃ³ aqui

### ğŸ“Š Regra de NegÃ³cio: CÃ¡lculo de Score Base

#### FÃ³rmula:

```
Score Base = (Idade Ã— 0.1) + (Renda Ã· 1.000) + (HistÃ³rico Ã— 5)
```

**Onde:**
- **Idade:** Anos de vida (ex: 30 anos â†’ 3.0 pontos)
- **Renda:** Renda mensal em R$ (ex: R$ 50.000 â†’ 50.0 pontos)
- **HistÃ³rico:** Anos como cliente (ex: 2 anos â†’ 10.0 pontos)

#### Assinatura da FunÃ§Ã£o:

```python
def calculate_base_score(age: int, income: float, history: int) -> float:
    """
    Args:
        age: Idade do cliente em anos (ex: 30)
        income: Renda mensal em reais (ex: 50000.0)
        history: Anos como cliente (ex: 2)
        
    Returns:
        Score base calculado
    """
```

#### Exemplos:

**Exemplo 1:**
```python
>>> ScoringLogic.calculate_base_score(30, 50000, 2)
63.0

# ExplicaÃ§Ã£o: (30 * 0.1) + (50000 / 1000) + (2 * 5)
#           = 3.0 + 50.0 + 10.0
#           = 63.0
```

**Exemplo 2:**
```python
>>> ScoringLogic.calculate_base_score(25, 30000, 1)
37.5

# ExplicaÃ§Ã£o: (25 * 0.1) + (30000 / 1000) + (1 * 5)
#           = 2.5 + 30.0 + 5.0
#           = 37.5
```

### ğŸ¯ Por que esta FunÃ§Ã£o Ã© TestÃ¡vel

1. **DeterminÃ­stica:** Mesma entrada â†’ Mesma saÃ­da
2. **Sem I/O:** NÃ£o precisa de rede, disco, ou serviÃ§os
3. **Sem estado:** NÃ£o depende de variÃ¡veis globais
4. **RÃ¡pida:** Executa em microssegundos

### ğŸ¯ Design Decision: MultiplicaÃ§Ã£o vs Soma

**Por que multiplicar e nÃ£o somar?**

#### MultiplicaÃ§Ã£o:
- âœ… Probabilidade baixa "veta" scores altos
- âœ… Escala naturalmente (0-100% de confianÃ§a)
- âœ… Comportamento intuitivo

#### Soma seria problemÃ¡tica:
- âŒ Probabilidade 0 nÃ£o zeraria o score
- âŒ Escalas incompatÃ­veis (score pode ser 100+, prob Ã© 0-1)

---

## Orchestrator - Dependency Injection

### ğŸ“‹ VisÃ£o Geral

Este arquivo representa a **ORQUESTRAÃ‡ÃƒO** do fluxo de negÃ³cio.
Ele coordena diferentes componentes, mas NÃƒO faz I/O nem lÃ³gica complexa.

### ğŸ¯ PrincÃ­pios Aplicados

#### 1. Dependency Injection (DI)
- As dependÃªncias (API client, ML model) sÃ£o INJETADAS via construtor
- NÃ£o criamos instÃ¢ncias dentro da classe
- Facilita testes: posso injetar mocks!

#### 2. Orchestration (CoordenaÃ§Ã£o)
- Esta classe sabe QUANDO chamar cada componente
- Mas nÃ£o sabe COMO cada componente funciona internamente
- Delega responsabilidades

#### 3. Inversion of Control (IoC)
- Quem cria a instÃ¢ncia controla as dependÃªncias
- O orchestrator nÃ£o decide qual API ou modelo usar
- Isso Ã© decidido "de fora" (no main ou no teste)

### ğŸ“š Conceito: Dependency Injection Pattern

#### âŒ SEM Dependency Injection (Acoplado)

```python
class Orchestrator:
    def __init__(self):
        self.api = CustomerApiClient()  # â† Criado aqui! Acoplado!
        self.model = load_model()        # â† NÃ£o consigo trocar!

    def generate_score(self, id):
        data = self.api.get_customer_data(id)  # â† Sempre usa essa API
        # Como testar sem fazer HTTP real?
```

#### âœ… COM Dependency Injection (Desacoplado)

```python
class Orchestrator:
    def __init__(self, api_client, ml_model):  # â† Recebe pronto!
        self.api_client = api_client  # â† Posso injetar mock!
        self.ml_model = ml_model      # â† Posso injetar mock!

    def generate_score(self, id):
        data = self.api_client.get_customer_data(id)
        # Em testes: api_client = Mock()
        # Em produÃ§Ã£o: api_client = CustomerApiClient()
```

### ğŸ’¡ BenefÃ­cios da Dependency Injection

#### 1. Testabilidade

```python
# Teste com mocks
mock_api = Mock()
mock_model = Mock()
orchestrator = CustomerScoreOrchestrator(mock_api, mock_model)
# â†‘ Posso testar sem I/O real!
```

#### 2. Flexibilidade

```python
# Em produÃ§Ã£o
prod_api = CustomerApiClient()
prod_model = load_ml_model('prod_model.pkl')
orchestrator = CustomerScoreOrchestrator(prod_api, prod_model)

# Em desenvolvimento (com modelo diferente)
dev_model = DummyModel()  # Modelo fake para dev
orchestrator = CustomerScoreOrchestrator(prod_api, dev_model)
```

#### 3. Configurabilidade

```python
# Posso trocar implementaÃ§Ãµes sem mudar cÃ³digo
cached_api = CachedApiClient(CustomerApiClient())
orchestrator = CustomerScoreOrchestrator(cached_api, prod_model)
```

### ğŸ“ Design Pattern: Facade Pattern (Fachada)

O Orchestrator atua como uma "fachada" simplificando o uso de mÃºltiplos subsistemas:

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   ORCHESTRATOR      â”‚  â† Interface simples
          â”‚   generate_score()  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ delega para
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                     â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ API Clientâ”‚       â”‚  ML Model   â”‚       â”‚  Logic   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         I/O                  I/O              Pure Logic
```

**Cliente nÃ£o precisa saber dos detalhes de cada subsistema!**

### ğŸ“ Responsabilidades do Orchestrator

Orquestra o fluxo de cÃ¡lculo de score do cliente.

#### Responsabilidades:
1. Coordenar chamadas entre componentes
2. Transformar dados entre formatos
3. Definir a ORDEM de execuÃ§Ã£o

#### NÃƒO Ã© responsÃ¡vel por:
- âŒ Fazer I/O (delegado para api_client)
- âŒ Calcular lÃ³gica de negÃ³cio (delegado para ScoringLogic)
- âŒ Executar modelo ML (delegado para ml_model)

### ğŸ“ PadrÃ£o: Strategy Pattern (implÃ­cito)

Ao injetar diferentes `api_clients` ou `ml_models`, estamos permitindo diferentes "estratÃ©gias" sem mudar cÃ³digo.

**Exemplos:**
- `api_client` pode ser: HTTP, gRPC, Cache, Mock
- `ml_model` pode ser: LogisticRegression, RandomForest, DummyModel

---

## ğŸ“š Resumo dos PadrÃµes

| PadrÃ£o | LocalizaÃ§Ã£o | BenefÃ­cio Principal |
|--------|-------------|---------------------|
| **Adapter** | API Client | Isola dependÃªncias externas |
| **Pure Functions** | Scoring Logic | Testabilidade sem mocks |
| **Dependency Injection** | Orchestrator | Flexibilidade e testabilidade |
| **Facade** | Orchestrator | Simplifica interface complexa |
| **Strategy** | Todo o sistema | Permite trocar implementaÃ§Ãµes |

---

## ğŸ¯ PrincÃ­pios SOLID Aplicados

- **S**ingle Responsibility: Cada classe tem uma responsabilidade
- **O**pen/Closed: ExtensÃ­vel via injeÃ§Ã£o de dependÃªncia
- **L**iskov Substitution: Mocks substituem implementaÃ§Ãµes reais
- **I**nterface Segregation: Interfaces mÃ­nimas e focadas
- **D**ependency Inversion: Core nÃ£o depende de infraestrutura
